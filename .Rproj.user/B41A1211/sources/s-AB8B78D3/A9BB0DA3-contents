###############################################
### Copyright Suave Software Limited 2020   ###
### All reights reserved                    ###
### Contact david.elms@statementreader.com  ###
###############################################


# LIBRARIES ----
# Shiny
library(shiny)
library(shinyWidgets)
library(shinythemes)
library(shinyFiles)
library(shinyjs)
library(DT)

library(mongolite) # Resource: https://jeroen.github.io/mongolite/
library(jsonlite)
library(RSQLite)

library(config)

library(tidyverse)
library(lubridate)
library(plyr) #rbind.fill
library(readxl)
library(openxlsx)  #for write

library(rdrop2)  #https://github.com/karthik/rdrop2

library(httr)
library(httpuv)
library(curl)
library(jsonlite)
library(base64enc)


#SETUP
options(shiny.maxRequestSize = 30*1024^2)
theme <- "paper"
button_theme_search <- "primary"
Sys.setenv(R_CONFIG_ACTIVE = "local")  # use "default" for prototyping, "production" for production
config <- config::get(file = "../config.yaml")
source(file = "02_db_scripts.R")
source(file = "03_file_scripts_general.R")
source(file = "08_gladage_export.R")
source(file = "09_paypal_export.R")
source(file = "04_user_base.R")


# FUNCTIONS ----
navbar_page_with_inputs <- function(...,inputs) {
    navbar <- shiny::navbarPage(...)
    
    form <- tags$form(class="navbar-form navbar-right",inputs)
    
    navbar[[3]][[1]]$children[[1]]$children[[2]] <- htmltools::tagAppendChild(
        navbar[[3]][[1]]$children[[1]]$children[[2]],form
    )
    
    return (navbar)
}
my_panel_card <- function(title,subtitle,...) {
    div(
        class = "", 
        div(
            class = "panel-header",
            h3(title,tags$small(subtitle),style="margin-top: 0px;")
        ),
        div(
            class = "panel-body",style = "padding:0px;",
            ...
        ),
    )
}
stats_cards <- function(id,icon) {
    div(
        class = "",
        style="padding:0px;margin-top:10px;margin-bottom:10px;display:block;",

        div(style="display:inline-block; width:100%;margin:0px",class="row",    
            valueBox(value = str_c(id,"_value_no1"),subtitle = str_c(id,"_subtitle_value_no1"),icon = icon$count_column,color = "steelblue"),
            valueBox(value = str_c(id,"_value_no2"),subtitle = str_c(id,"_subtitle_value_no2"),icon = icon$sum_column,color = "steelblue"),
            valueBox(value = str_c(id,"_value_no3"),subtitle = str_c(id,"_subtitle_value_no3"),icon = icon$min_column,color = "steelblue"),
            valueBox(value = str_c(id,"_value_no4"),subtitle = str_c(id,"_subtitle_value_no4"),icon = icon$max_column,color = "steelblue")
        )
    )
}
valueBox <- function(value, subtitle, icon, color) {
    div(class = "col-sm-6 col-md-6 col-lg-3",style="margin-bottom: 10px;padding: 0px 4px 0px 4px;",
        div(class = "panel panel-primary",
            div(class = "panel-heading", style = paste0("background-color:", color),
                div(class = "row",
                    div(class = "col-xs-3",
                        icon(icon, "fa-5x")
                    ),
                    div(class = ("col-xs-9 text-right"),
                        div(style = ("font-size: 56px; font-weight: bold;"),
                            textOutput(outputId = value)
                        ),
                        textOutput(outputId = subtitle)
                    )
                )
            ),
        )
    )
}
sendnotification <- function(msg,duration,id,session) {
    print(msg)
    notification_id <<- showNotification(msg, 
                                         duration = duration, 
                                         closeButton = FALSE, 
                                         id = id,
                                         session = session)
    addClass(id = str_c("shiny-notification-",id), class = "customclass2")
}

ui <- fluidPage(
    useShinyjs(),
    
    # CSS ----
    tags$head(
        # tags$link(rel = "stylesheet", type = "text/css", href = shinytheme("cyborg")),
        tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
    ),
    inlineCSS(list(.customclass1 = "top: 0 !important; left: calc(50% - 250px) !important; width: 500px !important;")),
    inlineCSS(list(.customclass2 = "background-color: rgba(241, 160, 85, 0.53) !important;")),
    tags$style(".btn-file {width: 180px; text-align: left;}"),
    tags$style(".shiny-input-container {margin-left: 5px;}"),
    tags$style(".shiny-file-input-progress {display: inline;}"),  #or none
    tags$style("input.form-control {width:0px; visibility: hidden}"),
    inlineCSS(list(.btn = "text-transform: none !important; -webkit-box-shadow: none !important; box-shadow: none !important; ")),

    #1.0 HEAD ----
    tagList(
        tags$head(HTML("<title>GLADAGE v2</title>"))
    ),
    style = "padding:0px;",

    
    #2.0 NAVBAR PAGE
    navbar_page_with_inputs(
        
        #2.1 Application Title
        title = div(
            tags$img(
                src = "https://www.business-science.io/img/business-science-logo.png",
                width = "30",
                height = "30",
                style = "webkit-filter: drop-shadow(3px 3px 3px #222)"
            ),
            "GLADAGE v2"
        ),
        collapsible = TRUE,
        theme = shinytheme(theme),
        
        #2.2 IMPORT/EXPORT BUTTONS ----
        inputs = div(
            downloadButton(outputId = "export_button", "EXPORT",class = str_glue("btn-{button_theme_search}"),style = "visibility: hidden;"),
            dropdownButton(
                fileInput(inputId = 'GetFileInput', label = NULL, multiple = TRUE,buttonLabel = "File",width = "200px"),  #accept = c('text/csv','text/comma-separated-values','.csv'
                actionLink(inputId = "UpdateFolderInput",label="Folder",class=str_glue("btn-block")),
                shinyDirLink(id = "SetDir", label = "Folder*", title = "Upload",style = "cursor: pointer;"),
                actionLink(inputId = "GetDropbox",label="DropBox",class=str_glue("btn-block")),
                actionLink(inputId = "GetPayPal",label="PayPal",class=str_glue("btn-block")),
                actionLink(inputId = "button4",label="Bills API",class=str_glue("btn-block")),
                circle = FALSE, status = "primary", #icon = icon("gear"), 
                width = "200px",
                tooltip = NULL,
                inline = TRUE,
                label = "IMPORT"
            ),            
            actionButton(inputId = "init",label="EXPORT",class=str_glue("btn-{button_theme_search}")),
        )
        
    ),

    #2.3.2 main panel output ----
    mainPanel(width = 12,style="padding:0px;",
        column(width = 12,
               shiny::actionButton(
                   inputId = "remove_tab_button",
                   label = NULL,
                   class = "btn-warning btn-sm pull-right",
                   icon = icon("trash",class = "fa-2x",lib = "font-awesome")),
               uiOutput(outputId = "temp_tabs"),
               br(),
               br(),
        ),
        
        #dev output
        # verbatimTextOutput(outputId = "temp_text"),
        # verbatimTextOutput(outputId = "temp_text2"),
        # tableOutput(outputId = "temp_table1")
    )

    
)

# SERVER ----
server <- function(input, output, session) {
    
    #setup
    reactive_values <- reactiveValues(ui_data = NULL,file_path = NULL,dev = NULL,user_base = NULL,dir_selected = NULL)
    notification_id <- NULL

    #get user_info (user_id,last import method,last folder,last selected tab,auto export,auto overwrite same import_type)!!!
    #get import_type and export_type settings, to change from default (eg VAT settings for QB export)!!!
    #help/debug mode!!!
    reactive_values$user_base <- get_user_credentials(user="david")  #filtered tibble
    reactive_values$dir_selected <- "/Users/david/Documents/r_odi/input"  #default value for 'server folder input'

    #check for user_base.rds, fill any missing list elements from user_base_default.rds!!!
    
    
    
    #load ui_data and fill tabs from db
    reactive_values$ui_data <- mongo_read_ui_data()


    #SERVER FOLDER INPUT
    # volumes <- list(columns=path.expand('~'))  #getVolumes() or path.expand('~')
    volumes <- list(volume="/Users/david/")
    # volumes <- getVolumes()
    shinyDirChoose(input, "SetDir", roots = volumes, session = session)
    observe({  #set folder
        req(is.list(input$SetDir))
        dir_selected <- input$SetDir %>% parseDirPath(volumes,.)
        reactive_values$dir_selected <- dir_selected
        
        print(str_c("got dir: ",dir_selected))
    })
    observeEvent(input$UpdateFolderInput,{
        print(str_c("running UpdateFolderInput with: ",reactive_values$dir_selected))
        
        dir_files <<- list.files(reactive_values$dir_selected, full.names = T)
        reactive_values$dev <- dir_files
        
        req(dir_files %>% length() >0)
        print("found files")
        
        #construct data.frame
        file_selected <- data.frame(row.names = NULL,
            name = file.info(dir_files) %>% row.names() %>% basename(),
            size = file.info(dir_files)$size,
            type = '',
            datapath = dir_files
        )
        
        #DUPLICATED from here...
        #save last folder to user_info
        # volumes <- list(columns=str_replace(file_selected$datapath,file_selected$name,""))
        # print(volumes)
        
        #pre open file checks, rule 1: is file already in myfirstcollection?
        new_file_check_output <- data.frame(row.names = NULL,file_selected, new_file_check_output=file_selected %>% split(x = .,f = file_selected$name) %>% sapply(function(x) {new_file_check(x$name,x$size)}) )  #%>% matrix(ncol = 5)
        # new_file_check_output <- reactive_values$file_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(reactive_values$file_path,.) %>% matrix(ncol = 2)
        skipped_files <- new_file_check_output[,1][new_file_check_output[,5]==FALSE] %>% matrix(ncol = 1)
        new_files_mat <- new_file_check_output[,1][new_file_check_output[,5]==TRUE] %>% matrix(ncol = 1)  #returns new files
        notification_id <<- sendnotification(msg = str_c("new_file_check_output:",new_files_mat, " skipped_files:",skipped_files,collapse = TRUE),
                                             duration = 2,id = "my_notification1",session = session)
        addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once
        req(new_files_mat %>% nrow() >0)  #only need to proceed with new files
        # isolate(reactive_values$file_path <- new_file_check_output)
        file_selected <- new_file_check_output[new_file_check_output$new_file_check_output==TRUE,]
        
        #pre open file checks, rule 2: is file in archive? if so, get 'exported' value
        # temp2 <- reactive_values_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(datapath=file_selected$datapath,new_file_check=.) %>% matrix(ncol = 2)
        new_files_exported_mat <- data.frame(row.names = NULL,file_selected,new_files_exported_mat=file_selected %>% split(x = .,f = file_selected$name) %>% 
                                                 sapply(function(x) {file_archive_check( name=x$name , size=file_selected[file_selected$name==x$name,"size"] , preserve=reactive_values$user_base$folder_ignore_already_exported)} ) )
        if (reactive_values$user_base$folder_ignore_already_exported) new_files_exported_mat <- new_files_exported_mat[new_files_exported_mat$new_files_exported_mat==0,]  #only keep if not already exported
        notification_id <<- sendnotification(msg = str_c("folder_ignore_already_exported:",reactive_values$user_base$folder_ignore_already_exported,
                                                         " after file_archive_check:",new_files_exported_mat$name %>% paste(.,collapse = ',')),
                                             duration = 2,id = "my_notification2",session = session)
        req(new_files_exported_mat %>% nrow() >0)
        
        #first line export_type identification
        new_files_exported_importgroup_mat <- data.frame(row.names = NULL,new_files_exported_mat , new_files_exported_importgroup_mat=new_files_exported_mat %>% split(x = .,f = new_files_exported_mat$name) %>% sapply(function(x) {get_group(x$datapath,x$name)}) )  #%>% cbind(new_files_exported_mat,'import_group'=.)  #=import_group
        notification_id <<- sendnotification(msg = str_c("import_group_output:",new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"] %>% paste(.,collapse = ',')),
                                             duration = 2,id = "my_notification3",session = session)
        req(sum(new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"]=="") ==0)  #no null import_groups
        new_files_exported_importgroup_mat <- new_files_exported_importgroup_mat[new_files_exported_importgroup_mat$new_files_exported_importgroup_mat != "",]  #remove missing import_groups
        
        #parameters for all imports
        import_datetime <- Sys.time()
        
        1:nrow(new_files_exported_importgroup_mat) %>% map(function(x) {
            addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once (added here solves lost center container issue)
            name <- new_files_exported_importgroup_mat[x,"name"] %>% unlist()
            size <- new_files_exported_importgroup_mat[x,"size"] %>% unlist()
            datapath <- new_files_exported_importgroup_mat[x,"datapath"] %>% unlist()
            exported <- new_files_exported_importgroup_mat[x,"new_files_exported_mat"] %>% unlist()
            import_group <- new_files_exported_importgroup_mat[x,"new_files_exported_importgroup_mat"] %>% unlist()
            # print("got datapath: ",datapath)  #datapath,exported,import_group
            
            #preprocessing
            data <- data_preprocessed(datapath,import_group)  #list(data=data)
            notification_id <<- sendnotification(msg = str_c("ran data_preprocessed: ",datapath),
                                                 duration = 2,id = str_c("my_notification",3+x),session = session)
            
            #add to db (mydata,import_group,import_basename,import_size,import_mtime) +import_time!!!
            # import_basename <- file.info(datapath) %>% row.names() %>% basename()
            # import_size <- file.info(datapath)$size
            # import_mtime <- file.info(datapath)$mtime
            my_import_id_list <- mongo_update_and_write(mydata = data,
                                                        import_group = import_group,
                                                        import_basename = name,
                                                        import_size = size,
                                                        import_mtime = '',
                                                        import_datetime = import_datetime,
                                                        exported = exported)
            my_import_id <- my_import_id_list$import_id
            notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write: ",my_import_id),
                                                 duration = 2,id = str_c("my_notification",4+x),session = session)
            
            #add to db (user_settings)
            mongo_update_and_write_user_settings(data,
                                                 my_import_id_list,
                                                 reactive_values$user_base$user_settings[[1]])
            notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write_user_settings: ",my_import_id),
                                                 duration = 2,id = str_c("my_notification",5+x),session = session)
            
            #add all data to new sqlite file
            sqlite_update_and_write(my_import_id,data)
            notification_id <<- sendnotification(msg = str_c("ran sqlite_update_and_write: ",my_import_id),
                                                 duration = 5,id = str_c("my_notification",6+x),session = session)
        })
        
        #update ui
        mongo_read_ui_data()
        reactive_values$ui_data <- ui_data
        #/DUPLICATED from here...
        

    })
    #LOCAL FILE INPUT
    observe({
        
        if (!is.null(input$GetFileInput)) {
            file_selected <- input$GetFileInput  #%>% parseFilePaths(volumes,.)  #data.frame
            reactive_values$file_path <- file_selected$datapath  #$name,size,type,datapath
            req(reactive_values$file_path %>% length() >0)
            
            #DUPLICATED from here...
            #save last folder to user_info
            # volumes <- list(columns=str_replace(file_selected$datapath,file_selected$name,""))
            # print(volumes)
            
            #pre open file checks, rule 1: is file already in myfirstcollection?
            new_file_check_output <- data.frame(row.names = NULL,file_selected, new_file_check_output=file_selected %>% split(x = .,f = file_selected$name) %>% sapply(function(x) {new_file_check(x$name,x$size)}) )  #%>% matrix(ncol = 5)
            # new_file_check_output <- reactive_values$file_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(reactive_values$file_path,.) %>% matrix(ncol = 2)
            skipped_files <- new_file_check_output[,1][new_file_check_output[,5]==FALSE] %>% matrix(ncol = 1)
            new_files_mat <- new_file_check_output[,1][new_file_check_output[,5]==TRUE] %>% matrix(ncol = 1)  #returns new files
            notification_id <<- sendnotification(msg = str_c("new_file_check_output:",new_files_mat, " skipped_files:",skipped_files,collapse = TRUE),
                                                 duration = 2,id = "my_notification1",session = session)
            addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once
            req(new_files_mat %>% nrow() >0)  #only need to proceed with new files
            # isolate(reactive_values$file_path <- new_file_check_output)
            file_selected <- new_file_check_output[new_file_check_output$new_file_check_output==TRUE,]
            
            #pre open file checks, rule 2: is file in archive? if so, get 'exported' value
            # temp2 <- reactive_values_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(datapath=file_selected$datapath,new_file_check=.) %>% matrix(ncol = 2)
            new_files_exported_mat <- data.frame(row.names = NULL,file_selected,new_files_exported_mat=file_selected %>% split(x = .,f = file_selected$name) %>% 
                                                     sapply(function(x) {file_archive_check( name=x$name , size=file_selected[file_selected$name==x$name,"size"] , preserve=reactive_values$user_base$folder_ignore_already_exported)} ) )
            if (reactive_values$user_base$folder_ignore_already_exported) new_files_exported_mat <- new_files_exported_mat[new_files_exported_mat$new_files_exported_mat==0,]  #only keep if not already exported
            notification_id <<- sendnotification(msg = str_c("folder_ignore_already_exported:",reactive_values$user_base$folder_ignore_already_exported,
                                                             " after file_archive_check:",new_files_exported_mat$name %>% paste(.,collapse = ',')),
                                                 duration = 2,id = "my_notification2",session = session)
            req(new_files_exported_mat %>% nrow() >0)
            
            #first line export_type identification
            new_files_exported_importgroup_mat <- data.frame(row.names = NULL,new_files_exported_mat , new_files_exported_importgroup_mat=new_files_exported_mat %>% split(x = .,f = new_files_exported_mat$name) %>% sapply(function(x) {get_group(x$datapath,x$name)}) )  #%>% cbind(new_files_exported_mat,'import_group'=.)  #=import_group
            notification_id <<- sendnotification(msg = str_c("import_group_output:",new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"] %>% paste(.,collapse = ',')),
                                                 duration = 2,id = "my_notification3",session = session)
            req(sum(new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"]=="") ==0)  #no null import_groups
            new_files_exported_importgroup_mat <- new_files_exported_importgroup_mat[new_files_exported_importgroup_mat$new_files_exported_importgroup_mat != "",]  #remove missing import_groups
            
            #parameters for all imports
            import_datetime <- Sys.time()
            
            1:nrow(new_files_exported_importgroup_mat) %>% map(function(x) {
                addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once (added here solves lost center container issue)
                name <- new_files_exported_importgroup_mat[x,"name"] %>% unlist()
                size <- new_files_exported_importgroup_mat[x,"size"] %>% unlist()
                datapath <- new_files_exported_importgroup_mat[x,"datapath"] %>% unlist()
                exported <- new_files_exported_importgroup_mat[x,"new_files_exported_mat"] %>% unlist()
                import_group <- new_files_exported_importgroup_mat[x,"new_files_exported_importgroup_mat"] %>% unlist()
                # print("got datapath: ",datapath)  #datapath,exported,import_group
                
                #preprocessing
                data <- data_preprocessed(datapath,import_group)  #list(data=data)
                notification_id <<- sendnotification(msg = str_c("ran data_preprocessed: ",datapath),
                                                     duration = 2,id = str_c("my_notification",3+x),session = session)
                
                #add to db (mydata,import_group,import_basename,import_size,import_mtime) +import_time!!!
                # import_basename <- file.info(datapath) %>% row.names() %>% basename()
                # import_size <- file.info(datapath)$size
                # import_mtime <- file.info(datapath)$mtime
                my_import_id_list <- mongo_update_and_write(mydata = data,
                                                            import_group = import_group,
                                                            import_basename = name,
                                                            import_size = size,
                                                            import_mtime = '',
                                                            import_datetime = import_datetime,
                                                            exported = exported)
                my_import_id <- my_import_id_list$import_id
                notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write: ",my_import_id),
                                                     duration = 2,id = str_c("my_notification",4+x),session = session)
                
                #add to db (user_settings)
                mongo_update_and_write_user_settings(data,
                                                     my_import_id_list,
                                                     reactive_values$user_base$user_settings[[1]])
                notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write_user_settings: ",my_import_id),
                                                     duration = 2,id = str_c("my_notification",5+x),session = session)
                
                #add all data to new sqlite file
                sqlite_update_and_write(my_import_id,data)
                notification_id <<- sendnotification(msg = str_c("ran sqlite_update_and_write: ",my_import_id),
                                                     duration = 5,id = str_c("my_notification",6+x),session = session)
            })
            
            #update ui
            mongo_read_ui_data()
            reactive_values$ui_data <- ui_data
            #/DUPLICATED from here...
        }
    })
    #DROPBOX FOLDER INPUT
    observeEvent(input$GetDropbox,{
        print("running input$GetDropbox")
        
        token <- ""
        if (!file.exists("drop_token.rds")) {
            print("no token")
            
            token <- drop_auth(key = config$drop_key,secret = config$drop_secret,new_user = TRUE,cache = FALSE)
            saveRDS(token, file = "drop_token.rds")
        } else {
            token <- readRDS("drop_token.rds")
            # drop_acc(dtoken = token)
            # drop_upload(dtoken = token,file = "temp.txt")
            # drop_download(dtoken = token, path = 'temp.txt',overwrite = TRUE)
            # drop_create('drop_test') #for automated output data/log???
        }
        
        #check token
        if (token == "") {
            print("no token")
            
            file.remove("drop_token.rds")
            return()
        }

        #all ok, proceed
        dir_files <- drop_dir(recursive = TRUE,dtoken = token)  #".tag" "name" "path_lower" "path_display" "id" "client_modified" "server_modified" "rev" "size" "content_hash"
        req(dir_files %>% nrow() >0)
        
        #empty server /drop_downloads_temp
        f <- list.files("drop_downloads_temp", include.dirs = F, full.names = T, recursive = T)
        file.remove(f)        
        
        #download files from dropbox to /drop_downloads_temp (do after file_archive_check!!!)
        dir_files %>% 
            split(x = .,f = dir_files$path_display) %>% 
            map(function(x) {drop_download(dtoken = token, path = x$path_display,overwrite = TRUE,local_path = "drop_downloads_temp")})
        
        #construct data.frame
        file_selected <- data.frame(row.names = NULL,
                                    name = dir_files$name,
                                    size = dir_files$size,
                                    type = '',
                                    datapath = str_c("drop_downloads_temp",dir_files$path_display)
        )
        
        #DUPLICATED from here...
        #save last folder to user_info
        # volumes <- list(columns=str_replace(file_selected$datapath,file_selected$name,""))
        # print(volumes)
        
        #pre open file checks, rule 1: is file already in myfirstcollection?
        new_file_check_output <- data.frame(row.names = NULL,file_selected, new_file_check_output=file_selected %>% split(x = .,f = file_selected$name) %>% sapply(function(x) {new_file_check(x$name,x$size)}) )  #%>% matrix(ncol = 5)
        # new_file_check_output <- reactive_values$file_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(reactive_values$file_path,.) %>% matrix(ncol = 2)
        skipped_files <- new_file_check_output[,1][new_file_check_output[,5]==FALSE] %>% matrix(ncol = 1)
        new_files_mat <- new_file_check_output[,1][new_file_check_output[,5]==TRUE] %>% matrix(ncol = 1)  #returns new files
        notification_id <<- sendnotification(msg = str_c("new_file_check_output:",new_files_mat, " skipped_files:",skipped_files,collapse = TRUE),
                                             duration = 2,id = "my_notification1",session = session)
        addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once
        req(new_files_mat %>% nrow() >0)  #only need to proceed with new files
        # isolate(reactive_values$file_path <- new_file_check_output)
        file_selected <- new_file_check_output[new_file_check_output$new_file_check_output==TRUE,]
        
        #pre open file checks, rule 2: is file in archive? if so, get 'exported' value
        # temp2 <- reactive_values_path %>% lapply(function(x) {new_file_check(x)}) %>% cbind(datapath=file_selected$datapath,new_file_check=.) %>% matrix(ncol = 2)
        new_files_exported_mat <- data.frame(row.names = NULL,file_selected,new_files_exported_mat=file_selected %>% split(x = .,f = file_selected$name) %>% 
                                                 sapply(function(x) {file_archive_check( name=x$name , size=file_selected[file_selected$name==x$name,"size"] , preserve=reactive_values$user_base$folder_ignore_already_exported)} ) )
        if (reactive_values$user_base$folder_ignore_already_exported) new_files_exported_mat <- new_files_exported_mat[new_files_exported_mat$new_files_exported_mat==0,]  #only keep if not already exported
        notification_id <<- sendnotification(msg = str_c("folder_ignore_already_exported:",reactive_values$user_base$folder_ignore_already_exported,
                                                         " after file_archive_check:",new_files_exported_mat$name %>% paste(.,collapse = ',')),
                                             duration = 2,id = "my_notification2",session = session)
        req(new_files_exported_mat %>% nrow() >0)
        
        #first line export_type identification
        new_files_exported_importgroup_mat <- data.frame(row.names = NULL,new_files_exported_mat , new_files_exported_importgroup_mat=new_files_exported_mat %>% split(x = .,f = new_files_exported_mat$name) %>% sapply(function(x) {get_group(x$datapath,x$name)}) )  #%>% cbind(new_files_exported_mat,'import_group'=.)  #=import_group
        notification_id <<- sendnotification(msg = str_c("import_group_output:",new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"] %>% paste(.,collapse = ',')),
                                             duration = 2,id = "my_notification3",session = session)
        req(sum(new_files_exported_importgroup_mat[,"new_files_exported_importgroup_mat"]=="") ==0)  #no null import_groups
        new_files_exported_importgroup_mat <- new_files_exported_importgroup_mat[new_files_exported_importgroup_mat$new_files_exported_importgroup_mat != "",]  #remove missing import_groups
        
        #parameters for all imports
        import_datetime <- Sys.time()
        
        1:nrow(new_files_exported_importgroup_mat) %>% map(function(x) {
            addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once (added here solves lost center container issue)
            name <- new_files_exported_importgroup_mat[x,"name"] %>% unlist()
            size <- new_files_exported_importgroup_mat[x,"size"] %>% unlist()
            datapath <- new_files_exported_importgroup_mat[x,"datapath"] %>% unlist()
            exported <- new_files_exported_importgroup_mat[x,"new_files_exported_mat"] %>% unlist()
            import_group <- new_files_exported_importgroup_mat[x,"new_files_exported_importgroup_mat"] %>% unlist()
            # print("got datapath: ",datapath)  #datapath,exported,import_group
            
            #preprocessing
            data <- data_preprocessed(datapath,import_group)  #list(data=data)
            notification_id <<- sendnotification(msg = str_c("ran data_preprocessed: ",datapath),
                                                 duration = 2,id = str_c("my_notification",3+x),session = session)
            
            #add to db (mydata,import_group,import_basename,import_size,import_mtime) +import_time!!!
            # import_basename <- file.info(datapath) %>% row.names() %>% basename()
            # import_size <- file.info(datapath)$size
            # import_mtime <- file.info(datapath)$mtime
            my_import_id_list <- mongo_update_and_write(mydata = data,
                                                        import_group = import_group,
                                                        import_basename = name,
                                                        import_size = size,
                                                        import_mtime = '',
                                                        import_datetime = import_datetime,
                                                        exported = exported)
            my_import_id <- my_import_id_list$import_id
            notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write: ",my_import_id),
                                                 duration = 2,id = str_c("my_notification",4+x),session = session)
            
            #add to db (user_settings)
            mongo_update_and_write_user_settings(data,
                                                 my_import_id_list,
                                                 reactive_values$user_base$user_settings[[1]])
            notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write_user_settings: ",my_import_id),
                                                 duration = 2,id = str_c("my_notification",5+x),session = session)
            
            #add all data to new sqlite file
            sqlite_update_and_write(my_import_id,data)
            notification_id <<- sendnotification(msg = str_c("ran sqlite_update_and_write: ",my_import_id),
                                                 duration = 5,id = str_c("my_notification",6+x),session = session)
        })
        
        #update ui
        mongo_read_ui_data()
        reactive_values$ui_data <- ui_data
        #/DUPLICATED from here...
            
    })
    #PAYPAL INPUT
    observeEvent(input$GetPayPal,{
        print("running input$GetPayPal")
        
        if (!file.exists("paypal_token.rds")) {
            print("no token")
            #Settings AND Credentials
            #client_id <- "AeTSn0CWzwEbNB4UgN0F_O_hKfkXVJdWvgkRnorKh-Ff5uTWRIlBL7v9t-yUo7i6Sj2MegRPXQSwr_O0"  #sandbox
            #client_secret <- "EMasA3x7M-5lJdxkG0oUsIrEl81Mx2V6Q6YHAeeE1612PTwMVoSTMOY0HvQTXZG_Otx49WSrx9wSlKvz"  #sandbox
            client_id <- "AWRtDRArYqRWWlwjJmWQUGw977b_XOXloehcl-AqDgmX_LPtKobb86z9GdRj"
            client_secret <- "ED0LkRBdcegxbABn2wsWyfY2FeQcjZSNaQRdY7m09o2-Hinl-GpjTDRp8SPC"
            #oauth_api <- "https://api.sandbox.paypal.com/v1/oauth2/token/"  #sandbox
            oauth_api <- "https://api.paypal.com/v1/oauth2/token/"
            authorize <- base64enc::base64encode(charToRaw(paste0(client_id,":",client_secret)))
            access_token <- ""
            
            # Get Access Token
            form_params <- list(grant_type = "client_credentials")
            oauth2_token <- POST(oauth_api, body = form_params, encode = "form", add_headers('Authorization'= paste0("Basic ", authorize)), verbose())
            
            j_son <- fromJSON(content(oauth2_token, as = "text"))
            token <- j_son$access_token

            saveRDS(token, file = "paypal_token.rds")
        } else {
            token <- readRDS("paypal_token.rds")
        }
        
        #paypal_api_check
        #transactions_api <- paste0("https://api.sandbox.paypal.com/v1/reporting/transactions?start_date=", start_date,"&end_date=", end_date)  #sandbox
        transactions_api <- paste0("https://api.paypal.com/v1/reporting/transactions?start_date=", start_date,"&end_date=", end_date)
        start_date <- "2020-09-01T00:00:00-0700"  #change to last 30 days!!!
        end_date <- "2020-09-29T23:59:59-0700"  #change to yesterday!!!
        datas <- GET(transactions_api, accept_json(), add_headers('Authorization'= paste0("Bearer ", token)))
        datas$status_code == 200  #0/1
        
        #check status
        if(datas$status_code != 200){  #error from paypal api
            result <- fromJSON(content(datas, as = "text"))
            print(paste0('ERROR_NAME = ', result$name))
            print(paste0('ERROR_DETAILS = ', result$details$issue))
            
            file.remove("paypal_token.rds")
            return()
        }
        if (result$transaction_details %>% nrow() ==0) {  #check number of transactions???
            print("no rows in transaction_details")
            return()
        }
        
        #all ok, proceed
        addClass(id = "shiny-notification-panel", class = "customclass1")  #need to run once (added here solves lost center container issue)
        name <- "import_basename"
        size <- 1
        datapath <- "paypal_token.rds"
        exported <- 0
        import_group <- "PAYPAL|PAYPALAPI"
        import_datetime <- Sys.time()
        # print("got datapath: ",datapath)  #datapath,exported,import_group
        
        #preprocessing
        data <- data_preprocessed(datapath,import_group)  #list(data=data)
        notification_id <<- sendnotification(msg = str_c("ran data_preprocessed: ",datapath),
                                             duration = 2,id = str_c("my_notification",3),session = session)
        
        #add to db (mydata,import_group,import_basename,import_size,import_mtime) +import_time!!!
        # import_basename <- file.info(datapath) %>% row.names() %>% basename()
        # import_size <- file.info(datapath)$size
        # import_mtime <- file.info(datapath)$mtime
        my_import_id_list <- mongo_update_and_write(mydata = data,
                                                    import_group = import_group,
                                                    import_basename = name,
                                                    import_size = size,
                                                    import_mtime = '',
                                                    import_datetime = import_datetime,
                                                    exported = exported)
        my_import_id <- my_import_id_list$import_id
        notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write: ",my_import_id),
                                             duration = 2,id = str_c("my_notification",4),session = session)
        
        #add to db (user_settings)
        mongo_update_and_write_user_settings(data,
                                             my_import_id_list,
                                             reactive_values$user_base$user_settings[[1]])
        notification_id <<- sendnotification(msg = str_c("ran mongo_update_and_write_user_settings: ",my_import_id),
                                             duration = 2,id = str_c("my_notification",5),session = session)
        
        #add all data to new sqlite file
        sqlite_update_and_write(my_import_id,data)
        notification_id <<- sendnotification(msg = str_c("ran sqlite_update_and_write: ",my_import_id),
                                             duration = 5,id = str_c("my_notification",6),session = session)

        #update ui
        mongo_read_ui_data()
        reactive_values$ui_data <- ui_data
        
    })
    
    # create the ui DataTables, changes with ui_data
    observe({
        # print(str_c("updating non-overview datatables: ",length(reactive_values$ui_data)))
        lapply(seq_along(reactive_values$ui_data),function(x) {
            req(reactive_values$ui_data[[x]])  #removes error adding to empty db???
            # print(str_c("updating non-overview datatables for: ",x," - ",reactive_values$ui_data[[x]]$mytitle))
            output[[reactive_values$ui_data[[x]]$mytitle]] = DT::renderDataTable({
                DT::datatable(data = reactive_values$ui_data[[x]]$data,
                              selection = 'none',
                              options=list(
                                  searching=FALSE,
                                  lengthChange=FALSE
                              ),
                              rownames=NULL,
                ) #%>% DT::formatStyle(0, cursor = 'pointer')
            })
            #value_boxes (count = NULL,sum = NULL,earliest = NULL,latest = NULL)
            #id=documents_[title]_value_no1
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_value_no1") ]] = renderText({
                reactive_values$ui_data[[x]]$count_value
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_value_no2") ]] = renderText({
                reactive_values$ui_data[[x]]$sum_value
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_value_no3") ]] = renderText({
                reactive_values$ui_data[[x]]$min_value
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_value_no4") ]] = renderText({
                reactive_values$ui_data[[x]]$max_value
            })
            #id=documents_[title]_subtitle_value_no1
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_subtitle_value_no1") ]] <- renderText({
                reactive_values$ui_data[[x]]$valuebox_subtitles$count_label
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_subtitle_value_no2") ]] <- renderText({
                reactive_values$ui_data[[x]]$valuebox_subtitles$sum_label
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_subtitle_value_no3") ]] <- renderText({
                reactive_values$ui_data[[x]]$valuebox_subtitles$min_label
            })
            output[[ str_c("documents_",reactive_values$ui_data[[x]]$mytitle,"_subtitle_value_no4") ]] <- renderText({
                reactive_values$ui_data[[x]]$valuebox_subtitles$max_label
            })
            
        })
    })
    observe({
        req(length(reactive_values$ui_data)>0)
        output$overview <- DT::renderDataTable({
            DT::datatable(
                data = reactive_values$ui_data %>% lapply(function(x) {
                    tibble(x$mytitle,x$import_basename,x$import_type,x$import_datetime %>% format("%x %X"))
                }) %>% bind_rows() %>% setNames(c("","File name","Import type","Import time")),
                selection = list( target='row',
                                  selected=1:length(reactive_values$ui_data) %>% lapply(function(x) {
                                      if (reactive_values$ui_data[[x]]$selected_ui==0) x
                                  }) %>% unlist()
                                      ),  #selected=c(1,2)
                options=list(
                    searching=FALSE,
                    lengthChange=FALSE,
                    paging=FALSE,
                    ordering=FALSE,
                    info=FALSE
                ),
                rownames=NULL,
            )
        })
    })
    #https://datatables.net/reference/option/
    # datatable( data = mtcars
    #            , extensions = 'Buttons'
    #            , options = list(
    #                dom = "Blfrtip"
    #                , buttons =
    #                    list("copy", list(
    #                        extend = "collection"
    #                        , buttons = c("csv", "excel", "pdf")
    #                        , text = "Download"
    #                    ) ) # end of buttons customization
    #
    #                # customize the length menu
    #                , lengthMenu = list( c(10, 20, -1) # declare values
    #                                     , c(10, 20, "All") # declare titles
    #                ) # end of lengthMenu customization
    #                , pageLength = 10
    #
    #
    #            ) # end of options
    #
    # ) # end of datatables
    
    
    selected_tab <- eventReactive(input$tab_panel_stock_chart, {
        if (is.character(input$tab_panel_stock_chart)) {
            # Tab already selected
            selected_tab <- input$tab_panel_stock_chart
        } else {
            # Tab panel not built yet
            selected_tab <- NULL
        }

        selected_tab

    }, ignoreNULL = FALSE)
    
    #overview tab valuebox
    output$overview_value_no1 <- renderText({
        reactive_values$ui_data %>% length()
    })
    output$overview_value_no2 <- renderText({
        reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% unlist() %>% unique() %>% length()
    })
    output$overview_value_no3 <- renderText({
        reactive_values$ui_data %>% lapply(function(x) {strsplit(x$import_group,"\\|")[[1]][1]}) %>% unlist() %>% unique() %>% length()
    })
    output$overview_value_no4 <- renderText({
        temp <- 0
        if (reactive_values$ui_data %>% length() >0) temp <- reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% unlist() %>% table() %>% pluck(1)
        temp
    })
    output$overview_subtitle_value_no1 <- renderText({
        "documents"
    })
    output$overview_subtitle_value_no2 <- renderText({
        if (reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% unlist() %>% unique() %>% length() ==1) {
            reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% pluck(1) %>% str_c("unique import_type (",.,")")
        } else {
            "unique import_type"
        }
    })
    output$overview_subtitle_value_no3 <- renderText({
        if (reactive_values$ui_data %>% lapply(function(x) {strsplit(x$import_group,"\\|")[[1]][1]}) %>% unlist() %>% unique() %>% length() ==1) {
            reactive_values$ui_data %>% lapply(function(x) {strsplit(x$import_group,"\\|")[[1]][1]}) %>% unlist() %>% pluck(1) %>% str_c("unique export_type (",.,")")
        } else {
            "unique export_types"
        }
    })
    output$overview_subtitle_value_no4 <- renderText({
        if (reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% unlist() %>% unique() %>% length() ==1) {
            reactive_values$ui_data %>% lapply(function(x) {x$import_type}) %>% unlist() %>% table() %>% names() %>% pluck(1) %>% str_c("maximum import_type (",.,")")
        } else {
            "maximum import_type"
        }
    })
    
    
    #export_button
    observeEvent(input$init, {
        print("export_button")
        test1 <- FALSE
        test2 <- FALSE
        test3 <- FALSE
        
        #mongo_get_selected_ui()
        selected_imports <- mongo_get_selected_ui() #list(list(import_id=import_id,export_type=export_type,import_type=import_type),...)
        test1 <- selected_imports %>% length()>0
        notification_id <<- sendnotification(msg = str_c("selected_imports:",selected_imports %>% as.character(),"(",test1,")",collapse = TRUE),
                                             duration = 4,id = "my_notification11",session = session)
        addClass(id = "shiny-notification-panel", class = "customclass1")

        #check_single_export_type
        if (test1) {
            selected_imports_check <- selected_imports %>% lapply(function(x) {x$export_type}) %>% unique() %>% length() ==1
            test2 <- selected_imports_check
            notification_id <<- sendnotification(msg = str_c("selected_imports_check:",selected_imports_check),
                                                 duration = 2,id = "my_notification12",session = session)
        }

        #match_export_rules()
        if (test2) {
            export_rules_check <- match_export_rules(selected_imports) ==1
            test3 <- export_rules_check
            notification_id <<- sendnotification(msg = str_c("export_rules_check: ",export_rules_check),
                                                 duration = 2,id = "my_notification13",session = session)
        }
        
        #check options for export_type
        if (test3) {
            my_export_options <- get_export_options(selected_imports)  #add user selection!!! For now priority:FILE,QBO
            
            if ("FILE" %in% my_export_options) {
                shinyjs::runjs("document.getElementById('export_button').click();")  #expects file path
                return()
            }
            
            if ("QBO" %in% my_export_options) {
                print("checking for QBO")

                #SETTINGS AND CREDENTIALS
                client_id <- "AB20eoIiVki4LwFEXeqiqEp4idZf2rCUOfgPaFu0t6D0bUfXZd"
                client_secret <- "a5cm9FNK6qsUXzXRewhh4br0age17qLUuSvg0mJN"
                realm_id <- "4620816365149353360"
                scope <- "com.intuit.quickbooks.accounting"
                # url_auth_code <- "https://appcenter.intuit.com/connect/oauth2"
                url_query = paste("https://sandbox-quickbooks.api.intuit.com/v3/company/",realm_id,"/query?query=SELECT%20%2a%20FROM%20Customer", sep="")
                oauth_url = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
                authorize <- base64enc::base64encode(charToRaw(paste0(client_id,":",client_secret)))
                redirect_uri = "http://localhost:1410/"
                
                if (!file.exists("qbo_token.rds")) {
                    print("no token")

                    #GET ACCESS TOKEN
                    access_token <- ""
                    endPoint <- oauth_endpoint(request = NULL,
                                               authorize = "https://appcenter.intuit.com/connect/oauth2",
                                               access = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer")
                    
                    App <- oauth_app("Gladage",
                                     key = client_id,
                                     secret = client_secret,
                                     redirect_uri = redirect_uri)
                    
                    oauth2_token <- oauth2.0_token(endpoint = endPoint,
                                                   app = App,
                                                   scope = scope,
                                                   type = "application/x-www-form-urlencoded",
                                                   cache = T)
                    
                    # Set access token
                    tmp <- strsplit(toString(names(oauth2_token$credentials)), '"')
                    for (i in 1:length(tmp[[1]])){
                        if(tmp[[1]][i] == 'access_token'){
                            access_token = tmp[[1]][i+2]
                        }
                    }
                    
                    #if error file.remove(qbo_token.rds)!!!
                    saveRDS(access_token, file = "qbo_token.rds")
                } else {
                    access_token <- readRDS("qbo_token.rds")
                }
                
                #check token
                if (access_token == "") {
                    print("no token")
                    
                    file.remove("qbo_token.rds")
                    return()
                }
                
                success_check <- run_export_processing(selected_imports=selected_imports,export_mode="QBO")  #send user_settings??? send access_token!!!
                print(success_check)
                return()
            }
            
        }#end of test3
    })
    output$export_button <- downloadHandler(
        filename = function() {
            paste("my_download", ".xlsx", sep = "")
        },
        content = function(file) {
            #run_export_processing()
            selected_imports <- mongo_get_selected_ui()
            my_output <- run_export_processing(selected_imports=selected_imports,export_mode="FILE")  #send user_settings??? get path
            mongo_update_exported(selected_imports)
            notification_id <<- sendnotification(msg = str_c("mongo_update_exported:",selected_imports %>% as.character(),collapse = TRUE),
                                                 duration = 2,id = "my_notification14",session = session)
            
            # wb <- createWorkbook()
            # addWorksheet(wb, "my_R_gladage")
            # writeDataTable(wb, 1, my_output)
            # saveWorkbook(wb, file, overwrite = TRUE)
            
            #write.csv(my_output, file, row.names = FALSE)
            file.copy(my_output$filepath,file,overwrite = TRUE)
            #file.remove(my_output$filepath)
            
            notification_id <<- sendnotification(msg = str_c("saveWorkbook!!! ",file),
                                                 duration = 5,id = "my_notification15",session = session)
        
        }
    )
    
    
    
    #delete tab
    observeEvent(input$remove_tab_button,{
        if (selected_tab() == "Overview") {
            unselected_imports <- mongo_get_selected_ui(param=0)  #list(list(import_id=import_id,export_type=export_type,import_type=import_type),...)            
            unselected_imports %>% map(function(x) {x$import_id} %>% mongo_delete(.))
            unselected_imports %>% map(function(x) {x$import_id} %>% sqlite_delete(.))
            
            notification_id <<- sendnotification(msg = str_c("remove_tab_button:",unselected_imports %>% paste(.,collapse = '')),
                                                 duration = 2,id = "my_notification21",session = session)
            addClass(id = "shiny-notification-panel", class = "customclass1")
        } else {
            output[[selected_tab()]] <- NULL  #NULL DT::datatable otherwise get error for data
            output[[str_c("documents_",selected_tab(),"_value_no1")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_value_no2")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_value_no3")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_value_no4")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_subtitle_value_no1")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_subtitle_value_no2")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_subtitle_value_no3")]] <- NULL  #NULL DT::datatable otherwise get error
            output[[str_c("documents_",selected_tab(),"_subtitle_value_no4")]] <- NULL  #NULL DT::datatable otherwise get error
            mongo_delete(selected_tab())
            sqlite_delete(selected_tab())
            
            notification_id <<- sendnotification(msg = str_c("remove_tab_button:",selected_tab()),
                                                 duration = 2,id = "my_notification22",session = session)
            addClass(id = "shiny-notification-panel", class = "customclass1")
        }

        mongo_read_ui_data()
        
        if (ui_data %>% length() ==0) {
            output[["overview"]] <- NULL  #NULL DT::datatable otherwise get error for data
        }
        reactive_values$ui_data <- ui_data
        
        #same, also works, more efficient:
        # temp <- lapply(seq_along(reactive_values$ui_data) , function(x) {
        #                 if ( reactive_values$ui_data[[x]]$mytitle != selected_tab() ) {
        #                     reactive_values$ui_data[[x]]
        #                 } else {
        #                     output[[selected_tab()]] <- NULL  #NULL DT::datatable otherwise get error
        #                 }
        #             })
        # temp <- temp %>% discard(is.null)
        # reactive_values$ui_data <- temp
    })

    output$temp_tabs <- renderUI({
        
        # First Tab Panel (intro/stats/document overview)
        document_panel_1 <- tabPanel(
            title = "Overview",
            stats_cards(id = "overview",icon = list(
                count_column = "angle-double-left",
                sum_column = "angle-double-up",
                min_column = "angle-double-right",
                max_column = "angle-double-down")),
            div(
                class = "", 
                div(
                    class = "panel-header",
                    h3("File Overview",style="margin-top: 0px;")
                ),
                div(
                    class = "panel-body",style = "padding:0px;",
                    DT::dataTableOutput("overview")
                ),
            )
        )
        
        # Document Panels
        document_tab_panels <- NULL
        if (length(reactive_values$ui_data) > 0) {

            document_tab_panels <- reactive_values$ui_data %>%
                map(.f = function(x) {
                    tabPanel(
                        title = x$mytitle,
                        stats_cards(id = str_c("documents_",x$mytitle),icon = x$valuebox_icons),
                        my_panel_card(
                            title=x$mytitle,
                            subtitle=paste(x$import_group,x$import_basename,x$import_size,x$import_mtime,sep = " | "),
                            DT::dataTableOutput(outputId = x$mytitle)
                        )
                    )
                })
            
        }
        
        # Building the Tabset Panel
        do.call(
            what = tabsetPanel,
            args = list(document_panel_1) %>%
                append(document_tab_panels) %>%
                append(list(id = "tab_panel_stock_chart", type = "tabs"))
        )
        
    })
    
    
    #selection from overview tab
    observe({

        #get selected import_id (all)
        s <- input[["overview_rows_selected"]]
        selected_import_ids <- reactive_values$ui_data %>% lapply(function(x){x$mytitle}) %>% .[s] %>% unlist()
        
        #set selected_ui at document level
        mongo_update_selected_ui(selected_import_ids)

    })
    
    
    
    
    
    

    #dev
    #watch multiple datatables for selected rows, and send results to db on each click
    output$temp_text <- renderText({
        c(
            reactive_values$dev %>% length()," : ",selected_tab()
            # selected_tab(),":",
            # reactive_values$ui_data %>% jsonlite::toJSON() %>% jsonlite::prettify()
        )
        # reactive_values$ui_data %>% length()
        
        # # selected_datatable_id <- paste0(selected_tab(),"_cell_clicked")  #,"_cell_clicked"
        # s <- input[["overview_cell_clicked"]]  #row,col,value
        # s <- s[1] %>% unlist()
        # mytitle = reactive_values$ui_data[s] %>% unlist() %>% .[1]
        # paste(s,mytitle,reactive_values$file_path,sep = " - ")

        # if (is.null(reactive_values$data)) return(tibble(selected_tab=selected_tab(),cell_clicked=unlist(s)))
        # reactive_values$data
        })
    output$temp_text2 <- renderText({
        paste(reactive_values$user_base$user)  #reactive_values$ui_data %>% length()
        # paste(overview_stats_from_db$document_count)
    })
    output$temp_table1 <- renderTable({
        reactive_values$dev
        # input$SetDir
    })
    # shinyjs::onclick(id = "button2_js", {
    #     output$temp_text=renderTable({
    #         tibble(empty=timestamp())
    #     })
    #     # delay(ms = 0, expr = {
    #     #     click(id = "file1")
    #     # })
    #     
    # })
    
}

shinyApp(ui, server)

